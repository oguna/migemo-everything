// main.rs (dragdrop.rs)

// Cargo.toml に以下を追加してください:
// [dependencies.windows]
// version = "0.56.0"
// features = [
//     "Win32_Foundation",
//     "Win32_Graphics_Gdi",
//     "Win32_System_Com",
//     "Win32_System_LibraryLoader",
//     "Win32_System_Memory",
//     "Win32_System_Ole", // OLE (ドラッグ&ドロップ) のために追加
//     "Win32_System_SystemServices",
//     "Win32_UI_Controls",
//     "Win32_UI_Shell",
//     "Win32_UI_Shell_Common",
//     "Win32_UI_WindowsAndMessaging",
// ]

use std::ffi::OsStr;
use std::os::windows::ffi::OsStrExt;
use std::path::Path;
use windows::{
    core::*,
    Win32::{
        Foundation::{DRAGDROP_S_DROP, DRAGDROP_S_CANCEL},
        Foundation::*,
        System::{
            Com::{
                CoInitializeEx, CoUninitialize, CoTaskMemFree,
                COINIT_APARTMENTTHREADED,
            },
            LibraryLoader::GetModuleHandleW,
            Ole::{DoDragDrop, IDropSource, IDropSource_Impl, DROPEFFECT, DROPEFFECT_COPY, DROPEFFECT_NONE},
            SystemServices::{SFGAO_FILESYSTEM, MK_LBUTTON, MODIFIERKEYS_FLAGS},
        },
        UI::{
            Controls::*,
            Shell::{
                Common::ITEMIDLIST,
                SHBindToParent, SHParseDisplayName, IShellFolder, SHCreateDataObject,
            },
            WindowsAndMessaging::*,
        },
    },
};

const ID_LISTVIEW: isize = 1000;

fn main() -> Result<()> {
    // 1. COMライブラリの初期化
    unsafe {
        CoInitializeEx(None, COINIT_APARTMENTTHREADED).ok()?;
    }

    let instance = unsafe { GetModuleHandleW(None)? };
    let window_class_name = w!("DragDropSample");

    let wc = WNDCLASSW {
        hCursor: unsafe { LoadCursorW(None, IDC_ARROW)? },
        hInstance: instance.into(),
        lpszClassName: window_class_name,
        style: CS_HREDRAW | CS_VREDRAW,
        lpfnWndProc: Some(wndproc),
        ..Default::default()
    };

    let atom = unsafe { RegisterClassW(&wc) };
    if atom == 0 {
        return Err(Error::from_win32());
    }

    let hwnd = unsafe {
        CreateWindowExW(
            WINDOW_EX_STYLE::default(),
            window_class_name,
            w!("Rust Drag Drop Sample"),
            WS_OVERLAPPEDWINDOW | WS_VISIBLE,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            800,
            600,
            None,
            None,
            Some(instance.into()),
            None,
        )
    }?;
    if hwnd.is_invalid() {
        return Err(Error::from_win32());
    }

    let mut message = MSG::default();
    while unsafe { GetMessageW(&mut message, None, 0, 0) }.as_bool() {
        unsafe {
            let _ = TranslateMessage(&message);
            DispatchMessageW(&message);
        }
    }

    // COMライブラリの解放
    unsafe { CoUninitialize() };
    Ok(())
}

extern "system" fn wndproc(window: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
    unsafe {
        match message {
            WM_CREATE => {
                let instance = GetModuleHandleW(None).unwrap();
                create_listview(window, instance.into()).unwrap();
                LRESULT(0)
            }
            WM_SIZE => {
                if let Ok(listview_hwnd) = GetDlgItem(Some(window), ID_LISTVIEW as i32) {
                    let mut rect = RECT::default();
                    GetClientRect(window, &mut rect).unwrap();
                    SetWindowPos(
                        listview_hwnd,
                        None,
                        0,
                        0,
                        rect.right - rect.left,
                        rect.bottom - rect.top,
                        SWP_NOZORDER,
                    )
                    .unwrap();
                }
                LRESULT(0)
            }
            WM_NOTIFY => {
                let nmhdr: &NMHDR = &*(lparam.0 as *const NMHDR);
                if nmhdr.idFrom as isize == ID_LISTVIEW {
                    // ドラッグ開始の通知を処理
                    if nmhdr.code == LVN_BEGINDRAG {
                        let nmlistview: &NMLISTVIEW = &*(lparam.0 as *const NMLISTVIEW);
                        handle_drag_begin(nmhdr.hwndFrom, nmlistview.iItem);
                    }
                }
                LRESULT(0)
            }
            WM_DESTROY => {
                PostQuitMessage(0);
                LRESULT(0)
            }
            _ => DefWindowProcW(window, message, wparam, lparam),
        }
    }
}

// リストビューを作成し、初期化する関数
fn create_listview(parent: HWND, instance: HINSTANCE) -> Result<()> {
    unsafe {
        let icex = INITCOMMONCONTROLSEX {
            dwSize: std::mem::size_of::<INITCOMMONCONTROLSEX>() as u32,
            dwICC: ICC_LISTVIEW_CLASSES,
        };
        let _ = InitCommonControlsEx(&icex);

        let style = WS_CHILD | WS_VISIBLE | WINDOW_STYLE(LVS_REPORT) | WINDOW_STYLE(LVS_SINGLESEL);

        let listview_hwnd = CreateWindowExW(
            WINDOW_EX_STYLE::default(),
            WC_LISTVIEW,
            w!(""),
            style,
            0,
            0,
            0,
            0,
            Some(parent),
            Some(HMENU(ID_LISTVIEW as *mut _)),
            Some(instance),
            None,
        )?;

        let mut col = LVCOLUMNW::default();
        col.mask = LVCF_TEXT | LVCF_WIDTH;
        col.cx = 250;

        let mut col_text: Vec<u16> = OsStr::new("名前").encode_wide().chain(Some(0)).collect();
        col.pszText = PWSTR(col_text.as_mut_ptr());
        SendMessageW(
            listview_hwnd,
            LVM_INSERTCOLUMNW,
            Some(WPARAM(0)),
            Some(LPARAM(&col as *const _ as isize)),
        );

        populate_listview(listview_hwnd)?;
    }
    Ok(())
}

// リストビューにカレントディレクトリのファイル/フォルダを populate する関数
fn populate_listview(listview_hwnd: HWND) -> Result<()> {
    let current_dir = std::env::current_dir().unwrap();
    let mut item_index = 0;

    for entry in std::fs::read_dir(current_dir).unwrap() {
        let entry = entry.unwrap();
        let path = entry.path();
        let file_name = path.file_name().unwrap_or_default().to_string_lossy();
        let mut item_text: Vec<u16> = OsStr::new(&*file_name).encode_wide().chain(Some(0)).collect();

        let item = LVITEMW {
            mask: LVIF_TEXT,
            iItem: item_index,
            pszText: PWSTR(item_text.as_mut_ptr()),
            ..Default::default()
        };

        unsafe {
            SendMessageW(
                listview_hwnd,
                LVM_INSERTITEMW,
                Some(WPARAM(0)),
                Some(LPARAM(&item as *const _ as isize)),
            );
        }
        item_index += 1;
    }
    Ok(())
}

// ドラッグ開始を処理する関数
fn handle_drag_begin(listview_hwnd: HWND, item_index: i32) {
    if item_index < 0 {
        return;
    }

    // 1. ドラッグされるアイテムのフルパスを取得
    let mut text_buffer: [u16; MAX_PATH as usize] = [0; MAX_PATH as usize];
    let mut item = LVITEMW {
        mask: LVIF_TEXT,
        iItem: item_index,
        iSubItem: 0,
        pszText: PWSTR(text_buffer.as_mut_ptr()),
        cchTextMax: MAX_PATH as i32,
        ..Default::default()
    };
    unsafe {
        SendMessageW(
            listview_hwnd,
            LVM_GETITEMW,
            Some(WPARAM(0)),
            Some(LPARAM(&mut item as *mut _ as isize)),
        );
    }

    let file_name = unsafe { item.pszText.to_string().unwrap() };
    let current_dir = std::env::current_dir().unwrap();
    let full_path = current_dir.join(&file_name);

    // 2. IDataObject を作成
    // ファイルのPIDLから、Shellは標準的なIDataObject（CF_HDROP形式のデータを持つ）を作成してくれる
    if let Ok((shell_folder, _pidl_absolute, pidl_relative)) = get_shell_folder_and_pidl(&full_path) {
        let data_object = unsafe {
            SHCreateDataObject(Some(shell_folder.cast().unwrap()), &[pidl_relative], None)
        };

        if let Ok(data_object) = data_object {
            // 3. IDropSource を作成
            let drop_source: IDropSource = DropSource::new().into();
            let mut effect = DROPEFFECT_NONE;

            // 4. DoDragDrop を呼び出してドラッグ&ドロップ操作を開始
            let result = unsafe {
                DoDragDrop(&data_object, &drop_source, DROPEFFECT_COPY, &mut effect)
            };

            // 結果のハンドリング（任意）
            if result == DRAGDROP_S_DROP {
                println!("Dropped with effect: {:?}", effect);
            } else if result == DRAGDROP_S_CANCEL {
                println!("Drag canceled");
            } else {
                println!("Drag failed with error: {:?}", result);
            }
        }
    }
}

// ファイルパスから IShellFolder と相対 PIDL を取得するヘルパー関数
fn get_shell_folder_and_pidl(path: &Path) -> Result<(IShellFolder, OwningPidl, *const ITEMIDLIST)> {
    let path_wide: Vec<u16> = path.as_os_str().encode_wide().chain(Some(0)).collect();
    let mut pidl_absolute = OwningPidl::new();

    unsafe {
        let sfgao: u32 = SFGAO_FILESYSTEM.0;
        SHParseDisplayName(
            PCWSTR(path_wide.as_ptr()),
            None,
            pidl_absolute.as_mut_ptr(),
            sfgao,
            None,
        )?;
    }

    let mut pidl_relative_ptr: *mut ITEMIDLIST = std::ptr::null_mut();
    let shell_folder: IShellFolder = unsafe {
        SHBindToParent(
            pidl_absolute.as_ptr(),
            Some(&mut pidl_relative_ptr),
        )?
    };

    Ok((shell_folder, pidl_absolute, pidl_relative_ptr))
}

// PIDLのメモリを管理するためのラッパ構造体
struct OwningPidl {
    ptr: *mut ITEMIDLIST,
}

impl OwningPidl {
    fn new() -> Self { Self { ptr: std::ptr::null_mut() } }
    fn as_ptr(&self) -> *const ITEMIDLIST { self.ptr }
    fn as_mut_ptr(&mut self) -> *mut *mut ITEMIDLIST { &mut self.ptr }
}

impl Drop for OwningPidl {
    fn drop(&mut self) {
        if !self.ptr.is_null() {
            unsafe { CoTaskMemFree(Some(self.ptr as *const _)) };
        }
    }
}


// IDropSourceインターフェースの実装
#[implement(IDropSource)]
struct DropSource;

impl DropSource {
    fn new() -> Self {
        Self
    }
}

#[allow(non_snake_case)]
impl IDropSource_Impl for DropSource {
    // ドラッグ中に定期的に呼び出される
    fn QueryContinueDrag(&self, fescapepressed: BOOL, grfkeystate: MODIFIERKEYS_FLAGS) -> HRESULT {
        // Escキーが押されたらキャンセル
        if fescapepressed.as_bool() {
            return DRAGDROP_S_CANCEL;
        }
        // 左マウスボタンが離されたらドロップ
        if (grfkeystate & MK_LBUTTON) == 0 {
            return DRAGDROP_S_DROP;
        }
        // それ以外の場合はドラッグを継続
        S_OK
    }

    // カーソルのフィードバックを与えるために呼び出される
    fn GiveFeedback(&self, _dweffect: DROPEFFECT) -> HRESULT {
        // Windowsにデフォルトのカーソルを使用させる
        DRAGDROP_S_USEDEFAULTCURSORS
    }
}
